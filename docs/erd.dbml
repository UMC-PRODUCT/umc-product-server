// Use DBML to define your database structure
// Docs: https://dbml.dbdiagram.io/docs

// created_at, updated_at은 모든 테이블에 있는 것을 가정합니다.
// base_entity로 제작


// === 사용자 및 회원가입 관련 ===

enum MemberStatus {
  PENDING // OAuth 로그인 시도 했던 사람
  ACTIVE // 유효한 회원
  INACTIVE // 휴면 계정
  WITHDRAWN // 탈퇴 계정
}

Table member {
  id bigint [pk, increment]
  name varchar
  nickname varchar
  email varchar
  school_id varchar [ref: > school.id]
  profile_image_id bigint
  status MemberStatus
  
  note: '회원가입 시 단계를 구분하기 위한 단계'

  // 사용자의 학교는 챌린저 활동 당시에 결정되도록 함.
  // 지원서에 지원하는 학교를 명시하도록 함.
}

enum OAuthProvider {
  GOOGLE
  APPLE
  KAKAO
}

Table member_oauth {
  id bigint [pk, increment]
  member_id bigint [ref: > member.id]
  provider OAuthProvider [note: 'OAuth Provider']
  provider_member_id varchar [note: 'OAuth Provider의 ID']
}

// === 약관 관련 ===

// Table terms {
//   id bigint [pk, increment]
//   content varchar
//   is_required bool
// }

// Terms는 따로 문서로 관리하도록 하고, 사용자가 어떤 약관을 동의하였는지 종류만 enum으로 표기하도록 함

enum TermType {
  SERVICE_POLICY
  PRIVACY_POLICY
  MARKETING_POLICY
}

Table member_term_agreement {
  id bigint [pk, increment]
  member_id bigint [ref: > member.id]
  term_type TermType
  agreed_at datetime [default: `now()`]
}

Table school {
  id bigint [pk, increment]
  name varchar
  logo_image_id bigint
  email_domain varchar [note: 'cau.ac.kr 처럼 학교별 이메일 ']
}

Table gisu {
  id bigint [pk, increment, note: '기수 번호 (1, 2, 3...)']
  is_active bool [note: '현재 활동 기수 여부']
  start_at datetime
  ends_at datetime
}

Table central_organization {
  id bigint [pk, increment]
  gisu_id bigint [ref: > gisu.id]
  name varchar [default: '9기 중앙운영사무국']
  
  Note: '중앙 조직은 단 하나만 존재'
}

Table chapter {
  id bigint [pk, increment]
  name varchar
  gisu_id bigint [ref: > gisu.id]
}

// 지부 내 학교
Table chapter_school {
  id bigint [pk, increment]
  chapter_id bigint [ref: > chapter.id]
  school_id bigint [ref: > school.id]
}

// === 웹 팀 지원서 관리는 이쪽에 ===


 // === 실제 활동 챌린저 관련 ===

enum ChallengerStatus {
  ACTIVE // 활성
  GRADUATED // 수료
  EXPELLED // 제명 (3OUT 포함)
  WITHDRAWN // 자진탈부
}

enum ChallengerPart {
  PLAN
  DESIGN
  WEB
  IOS
  ANDROID
  SPRINGBOOT
  NODEJS
}

Table challenger {
  id bigint [pk, increment]

  member_id bigint [ref: > member.id]
  part ChallengerPart
  gisu_id bigint [ref: > gisu.id]
  status ChallengerStatus
}

/**
e.g.

중앙대학교 회장: role_group = 중앙대학교 role = (scope:학교, name:회장)
중앙운영사무국 총괄: role_group = 중앙운영사무국 role = 중앙운영사무국 총괄

**/

enum OrganizationType {
  CENTRAL
  CHAPTER
  SCHOOL
}

Table challenger_role {
  id bigint [pk, increment]
  challenger_id bigint [ref: > challenger.id]
  role_type RoleType [not null]
  
  // 조직 정보 (계층 구조로 명확화)
  organization_type OrganizationType [not null, note: '조직 단위']
  organization_id bigint [not null, note: '지부, 학교 ID']
  
  // 파트장인 경우
  leadingPart ChallengerPart [null, note: '파트장인 경우만']
  
  gisu_id bigint [ref: > gisu.id]
}

enum PointType {
  BEST_WORKBOOK
  WARNING
  OUT
}

Table challenger_point  {
  id bigint [pk, increment]
  challenger_id bigint [ref: > challenger.id]
  type PointType [note: '상벌점 종류 구분'] 
  description varchar [note: '사유']
  related_workbook_id bigint [ref: > challenger_workbook.id, note: '사유가 되는 워크북 ID, 기입하지 않을 수도 있어서 nullable']
}

// === ROLE ===

// 역할을 일일히 만들어야 하나?
// 교내: 회장, 부회장, 파트장, 기타운영진
// 지부: 지부장
// 중앙운영사무국: 총괄, 부총괄, 교육국, 교육국원, 

enum RoleType {
  // 중앙
  CENTRAL_PRESIDENT           // 총괄
  CENTRAL_VICE_PRESIDENT      // 부총괄
  CENTRAL_DIRECTOR     // 국장
  CENTRAL_MANAGER    // 국원
  CENTRAL_PART_LEADER           // 중앙 파트장
  
  // 지부
  CHAPTER_LEADER         // 지부장
  CHAPTER_STAFF          // 지부 운영진
  
  // 학교
  SCHOOL_PRESIDENT       // 회장
  SCHOOL_VICE_PRESIDENT  // 부회장
  SCHOOL_PART_LEADER     // 파트장
  SCHOOL_STAFF           // 기타 운영진
  
  // 일반
  CHALLENGER             // 챌린저
}


// === Home ===



// === 공지 ===

Table notice {
  id bigint [pk, increment]

  title varchar
  content varchar
  author_challenger_id bigint [ref: > challenger.id, note: '작성자 챌린저 ID, 사용자 ID로 구분?']
  vote_id bigint [ref: > question.id, note: '투표가 없는 경우 null']
  link varchar [note: '링크']

  // 공지의 카테고리 (누가 작성할 수 있는지)
  scope OrganizationType [note: '어떤 scope에서 작성된 공지인지']
  organization_id bigint [not null, note: 'scope에 따라 중앙/지부/학교 ID']

  // 여러 카테고리의 사람에게 날리는 공지라면?
  // e.g. Spring&Node 대상 공지 (개발파트 공지)
  // e.g.2 Pla&Design 대상 공지

  // 누가 이 공지를 볼 수 있는지
  target_roles array [note: 'RoleType의 Array, null이면 전체 역할 대상 (회장단 or 지부장 공지용)']
  target_parts array [note: 'ChallengerPart의 Array, null이면 전체 파트 대상']
  target_gisu_id bigint [ref: > gisu.id, note: 'null아면 전체 기수 대상']

  // 알람 발송 대상이였는지도 저장해야 하나, OR 그냥 바로 발송하는 방식?
  should_notify bool [default: true, note: '알림 전송 여부']
  notified_at datetime [null, note: '알림 발송 시각']
}

Table notice_read {
  id bigint [pk, increment]
  notice_id bigint [ref: > notice.id]
  challenger_id bigint [ref: > challenger.id]
}

Table notice_image {
  id bigint [pk, increment]
  notice_id bigint [ref: > notice.id]
  image_id bigint [ref: > files.id]
}
// === INFRA: S3 ===

Table files {
  id bigint [pk, increment]
  original_file_name varchar
  stored_file_name varchar
  s3_key varchar
  content_type varchar
  file_size varchar
  status bool [note: '업로드 여부']
}

// ==========================================
// ================ 예은 작업본 시작 ================
// ==========================================

// === 활동 부분 ===

// 파트별 커리큘럼 부모
Table curriculum {
  id bigint [pk, increment]
  gisu_id bigint [ref: > gisu.id, note: '어떤 기수의 워크북인지']
  part ChallengerPart [note: '어떤 파트의 워크북인지']
}

// 파트별 커리큘럼 - 주차
// 작성할 수 있는 role을 한정 ? - 비즈니스로 할지, role을 엮을지
Table original_workbook {
  id bigint [pk, increment]
  curriculum_id bigint [ref: > curriculum.id, note: '해당 워크북이 소속된 커리큘럼']
  title varchar [note: '주차별 워크북 제목']
  description varchar [note: '워크북 설명']
  workbook_url varchar [note: 'Notion으로 워크북 관리 시 URL']
  order_no int [note: '워크북 순서']
}

Table workbook_mission {
  id bigint [pk, increment]
  title varchar [note: '미션 이름']
  mission_type MissionType [note: '미션의 형태']
  content varchar [note: '미션 내용']

  Note: '각 주차별 워크북에 있는 미션'
}

enum WorkbookStatus {
  PASS
  FAIL
  PENDING
}

enum MissionType {
  LINK [note: '링크 형식']
  MEMO [note: '메모 형식']
  PLAIN [note: '완료만 체크하는 형식']
}

// 주차별 챌린저 워크북
Table challenger_workbook {
  id bigint [pk, increment]
  challenger_id bigint [ref: > challenger.id]
  original_workbook_id bigint [ref: > original_workbook.id, note: '원본 워크북']
  status WorkbookStatus
  schedule_id bigint [ref: > schedule.id]
  is_best bool [note: '베스트 워크북 여부']
}

Table challenger_mission {
  id bigint [pk, increment]
  mission_id bigint [ref: > workbook_mission.id]
  challenger_workbook_id bigint [ref: > challenger_workbook.id]
  submission varchar [note: '제출물']
}

Table study_group {
  id bigint [pk, increment]
  name varchar [note: '스터디명']
  gisu_id bigint [ref: > gisu.id]
  group_leader_id bigint [ref: > challenger.id, note: '스터디장']

  note: '각 스터디를 나타냄, 학교/지부에는 속하지 않고 기수에만 속함.'
}

Table study_group_member {
  id bigint [pk, increment]
  group_id bigint [ref: > study_group.id]
  member_id bigint [ref: > challenger.id]

  note: '각 스터디에 속한 인원을 표현'
}

// ============= 스케쥴 ==================

// 해당 type에 따라서 출석 여부를 결정할 수 있는 사람의 권한 범위가 딸려옵니다.
enum ScheduleType {
  STUDY_SESSION
  CENTRAL_EVENT
  CHAPTER_EVENT
  SCHOOL_EVENT
}

// 모든 것은 일정으로 관리됨 (스터디, 행사 등)
Table schedule {
  id bigint [pk, increment]
  name varchar
  description varchar
  type ScheduleType
  author_challenger_id bigint [ref: > challenger.id, note: '일정을 생성한 챌린저 ID']

  starts_at datetime
  ends_at datetime
  location_name varchar // 장소는 텍스트 형식으로만 제공
  location point
  
  late_threshold interval [note: '지각 허용 시간', default: '00:10:00'] 
  absent_threshold interval [note: '결석 처리 시간', default: '00:30:00']
  attendance_radius int [default: 50, note: '인정 반경 (미터 단위)']


  // 정기 스터디도 스케쥴을 생성해야 하네
  // Spring Scheduler를 통해서 주기마다 생성하도록 해야할 것 같은데
}

enum AttendanceStatus {
  PENDING // 대기중
  PRESENT    // 출석
  PRESENT_PENDING
  LATE       // 지각
  LATE_PENDING // 지각으로 출석 승인 대기
  ABSENT     // 결석, 결석은 Scheduler에서 schedule의 absent threshold 경과 발견 시 자동으로 결석처리
  EXCUSED    // 인정결석 
  EXCUSED_PENDING
}

// 특정 schedule의 출석은 누가 변경할 수 있는가? 에 대한 명시가 필요해 보입니다.
// => schedule type 별로 조직을 결정.

// 각 스케쥴에 대한 출석 정보, 곧 개인별 출석부에 해당함. (이번 스케쥴의 출석 여부를 나타냄)
// 각 스케쥴을 생성할 때 미리 대상자를 결정해야 "출석부" 를 생성하는 것
Table schedule_attendance {
  id bigint [pk, increment]

  // 혹시 다른 기수 사람일 수도 있으니까 member로 연결
  member_id bigint [ref: > member.id] 
  schedule_id bigint [ref: > schedule.id]
  location point
  status AttendanceStatus
  // 승인은 무조건 운영진(=챌린저)가 해야함
  confirmed_challenger_id bigint [ref: > challenger.id]
  reason varchar [note: '출석 인정 사유 발생 시 입력']
}


// ==========================================
// ================ 세니 작업본 ================
// ==========================================

// 1. 커뮤니티 부분은 challenger_id가 아니라 member_id로 매핑해야 할 것 같은데 어떻게 생각하시나요?

enum CommunityPostCategory {
  LIGHTNING   [note: '번개']
  HOBBY       [note: '취미']
  QUESTION    [note: '질문']
  INFO        [note: '정보']
  SUGGESTION  [note: '건의']
  GENERAL     [note: '자유 (general로 이름 변경)']
}

enum CommunityPostRegion {
  SEOUL               [note: '서울']
  GYEONGGI_INCHEON    [note: '경기/인천']
  DAEJEON_CHUNGCHEONG [note: '대전/충청']
  BUSAN_GYEONGNAM     [note: '부산/경남']
}

enum CommunityPostStatus {
  OPEN [note: '모집 중']
  CLOSED [note: '마감']
}

Table community_post { // SuperType
	id bigint [pk, increment]
	title varchar
	content varchar
	is_anonymous bool [note: '건의사항의 경우 익명 여부']
	status CommunityPostStatus [default: 'OPEN']
	category CommunityPostCategory [not null]
	region CommunityPostRegion [not null]
	 
	// 관계 매핑
	author_member_id bigint [ref: > member.id]
}

// flash_gather라는 표현을 쓴다고 구글이 그러는데 lightening 쓸까요? ㅋㅋㅋ
// 별개로, 이건 번개모임의 정보를 나타내는 부분이니 해당 번개 자체를 나타내면 좋을 것 같아요.
Table flash_gather { // SubType
	id bigint [pk, increment]
	meeting_at datetime [note: '번개 날짜/시간']
  location varchar [note: '구체적인 장소']
  max_people int [note: '최대 인원']
  open_chat_link varchar [note: '오픈채팅방 링크']
  
  // 관계 매핑
  post_id bigint [not null, unique, ref: - community_post.id]
}

// community_like 정도로 축약해도 좋을 것 같습니다.
Table community_post_like {
	id bigint [pk, increment]
	
	// 관계 매핑
	member_id bigint [ref: > member.id]
	community_post_id bigint [ref: > community_post.id]
}

Table comment {
	id bigint [pk, increment]
	content varchar
	
	// 관계 매핑
	author_challenger_id bigint [ref: > challenger.id]
	community_post_id bigint [ref: > community_post.id]
	parent_comment_id bigint [null, ref: > comment.id, note: '자기 참조']
}

Table community_post_image {
  id bigint [pk, increment]
  post_id bigint [ref: > community_post.id]
  image_id bigint [ref: > files.id]
}

// ====== 폼 ======

Table form {
  id bigint [pk, increment]
  created_member_id bigint [ref: > member.id]
  title varchar
  description varchar
  is_active bool

  Note: '폼 한 개 (질문을 담고 있는)'
}

enum QuestionType {
  SHORT_TEXT
  LONG_TEXT
  RADIO
  CHECKBOX
  DROPDOWN
  SCHEDULE
  PORTFOLIO
}

enum FormResponseStatus {
  DRAFT
  SUBMITTED
}

enum RecruitmentPhase {
  BEFORE_APPLY
  APPLY_OPEN
  DOC_REVIEWING
  DOC_RESULT_PUBLISHED
  INTERVIEW_WAITING
  FINAL_REVIEWING
  FINAL_RESULT_PUBLISHED
  CLOSED
}

enum RecruitmentPartStatus {
  OPEN
  CLOSED
}

enum RecruitmentScheduleType {
  APPLY_WINDOW
  DOC_REVIEW_WINDOW
  DOC_RESULT_AT
  INTERVIEW_WINDOW
  FINAL_REVIEW_WINDOW
  FINAL_RESULT_AT
  OT_AT
  ACTIVITY_WINDOW
}

enum EvaluationStage {
  DOCUMENT
  FINAL
}

enum EvaluationDecision {
  PASS
  FAIL
  HOLD
}

Table question {
  id bigint [pk, increment]
  form_id bigint [ref: > form.id]
  // text or content?
  question_text varchar [note: '질문 본문']
  type QuestionType
  is_required bool
  order_no int

  Note: '폼에 있는 질문 1개'
}

Table question_option {
  id bigint [pk, increment]
  question_id bigint [ref: > question.id]
  content varchar
  order_no int

  Note: '객관식 유형의 질문들(단일 선택, 복수 선택 무관)의 옵션들'
}

Table form_response {
  id bigint [pk, increment]
  form_id bigint [ref: > form.id]
  respondent_member_id bigint [ref: > member.id, note: '응답한 사용자 id']
  status FormResponseStatus [not null, default: 'DRAFT']
  submitted_at timestamptz
  application_no varchar
  submited_ip varchar

  Note: '사용자의 응답지'
}

Table single_answer {
  id bigint [pk, increment]
  response_id bigint [ref: > form_response.id]
  question_id bigint [ref: > question.id]

  answered_as_type QuestionType [not null, note: '응답 당시 질문 타입']

  /* [JSONB 구조 및 규칙]
    변경 시 어떻게 할 것인지가 처리 필요
    
    1. 주관식 (SHORT_TEXT, LONG_TEXT)
       -> { "text": "답변내용" }
       
    2. 객관식 단일 (RADIO, DROPDOWN)
       -> { "selectedOptionId": 123 }
       
    3. 객관식 다중 (CHECKBOX)
       -> { "selectedOptionIds": [123, 124, 125] }
       
    * 주의: 질문 타입에 맞지 않는 키가 존재하거나 값이 있으면 안 됨.
  */
  value jsonb [not null, note: '답변 내용 전체를 JSON으로 저장']

  Note: '개별 질문에 대한 답변'
}

Table recruitment {
  id bigint [pk, increment]

  school_id bigint [ref: > school.id, note: '모집 주체(학교 단위)']
  gisu_id bigint [ref: > gisu.id]

  title varchar
  description varchar
  form_id bigint [ref: > form.id, note: '이 모집에서 사용하는 폼']

  is_active bool [default: true]
  phase RecruitmentPhase [default: 'BEFORE_APPLY', note: '대시보드 진행 단계(저장하거나 계산 가능)']

  Note: '모집 자체. 예: 중앙대 10기 추가모집'
}

Table recruitment_part {
  id bigint [pk, increment]
  recruitment_id bigint [ref: > recruitment.id]

  part ChallengerPart
  status RecruitmentPartStatus [default: 'OPEN', note: '파트별 모집중/마감(추가모집은 OPEN으로 전환)']

  Note: '파트별 모집 상태 관리'
}

Table recruitment_schedule {
  id bigint [pk, increment]
  recruitment_id bigint [ref: > recruitment.id]

  type RecruitmentScheduleType
  starts_at timestamptz
  ends_at timestamptz
  note varchar [note: '표시용 문구(선택)']

  Note: '모집 일정(활동 schedule과 분리). 단계별 윈도우/발표일 관리'
}

Table evaluation {
  id bigint [pk, increment]
  response_id bigint [ref: > form_response.id]

  stage EvaluationStage
  evaluator_member_id bigint [ref: > member.id, note: '평가자(운영진). challenger로 제한하면 challenger_id로 바꿔도 됨']

  score int
  decision EvaluationDecision [default: 'HOLD']
  memo varchar

  indexes {
    (response_id, stage) [unique, name: 'uq_evaluation_response_stage']
  }

  Note: '지원서 평가(서류/최종). 단일평가 가정'
}